// LoxKrox Generator
// A source generator for LoxKrox.
// Copyright (c) 2023 Chris Roberts (Krobbizoid).
// Released under the MIT License:
// https://krobbi.github.io/license/2023/mit.txt

// Generate LoxKrox.
fun generate_loxkrox(is_debug, add_line, add_module){
	add_line("// LoxKrox");
	add_line("// A Krox compiler written in Lox.");
	add_line("// Copyright (c) 2023 Chris Roberts (Krobbizoid).");
	add_line("// Released under the MIT License:");
	add_line("// https://krobbi.github.io/license/2023/mit.txt");
	add_line("");
	add_line("// This file was generated by `generator.lox`. Do not edit it directly.");
	add_line("// Run `generator.lox` or use `make regen` to regenerate LoxKrox from source.");
	
	if(is_debug){
		add_line("");
		add_line("// This is a debug build of LoxKrox.");
		add_line("// !!! Regenerate a release build before publishing.");
	}
	
	// Strings.
	add_module("string/char.lox");
	add_module("string/string.lox");
	
	// Collections.
	add_module("collections/list_node.lox");
	add_module("collections/list_iterator.lox");
	add_module("collections/list.lox");
	add_module("collections/map_node.lox");
	add_module("collections/map.lox");
	
	// Logger.
	add_module("logger/span.lox");
	add_module("logger/log_record.lox");
	add_module("logger/logger.lox");
	
	// Lexer.
	add_module("lexer/token_type.lox");
	add_module("lexer/token.lox");
	add_module("lexer/lexer.lox");
	
	// AST nodes.
	add_module("ast/ast_node.lox");
	add_module("ast/nodes/block_stmt_ast_node.lox");
	add_module("ast/nodes/export_ast_node.lox");
	add_module("ast/nodes/export_item_ast_node.lox");
	add_module("ast/nodes/expr_stmt_ast_node.lox");
	add_module("ast/nodes/fn_stmt_ast_node.lox");
	add_module("ast/nodes/import_ast_node.lox");
	add_module("ast/nodes/import_item_ast_node.lox");
	add_module("ast/nodes/literal_expr_ast_node.lox");
	add_module("ast/nodes/module_ast_node.lox");
	add_module("ast/nodes/nop_stmt_ast_node.lox");
	add_module("ast/nodes/paren_expr_ast_node.lox");
	add_module("ast/nodes/print_stmt_ast_node.lox");
	add_module("ast/nodes/program_ast_node.lox");
	
	// AST utilities.
	add_module("ast/ast_visitor.lox");
	add_module("ast/printer/ast_printer_node.lox");
	add_module("ast/printer/ast_printer.lox");
	
	// Parser.
	add_module("parser/parser.lox");
	
	// Importer.
	add_module("importer/importer.lox");
	
	// Lifecycle.
	add_module("tests/run_tests.lox");
	add_module("core/main.lox");
}

// Character constants.
var CHAR_LF = 10; // Line feed.

// Put a string of text to an output stream.
fun put_string(string, stream){
	var string_length = x_length(string);
	
	for(var i = 0; i < string_length; i = i + 1){
		x_put(x_ord(x_substring(string, i, 1)), stream);
	}
}

// Put a line of text to an output stream.
fun put_line(line, stream){
	put_string(line, stream);
	x_put(CHAR_LF, stream);
}

// Print an error message.
fun print_error(message){
	put_line(message, x_stderr());
}

// Pad a message to a length with a suffix.
fun pad(message, length, suffix){
	var message_length = x_length(message);
	
	while(message_length < length){
		message = message + suffix;
		message_length = message_length + 1;
	}
	
	return message;
}

// Return a path's parent path.
fun get_path_parent(path){
	var path_length = x_length(path);
	var parent_path = "";
	var parent_path_length = 0;
	
	for(var i = 0; i < path_length; i = i + 1){
		var char_string = x_substring(path, i, 1);
		
		if(char_string == "/" or char_string == "\"){
			parent_path = parent_path + "/";
			parent_path_length = i + 1;
		} else {
			parent_path = parent_path + char_string;
		}
	}
	
	return x_substring(parent_path, 0, parent_path_length);
}

// Run LoxKrox generator from a base path and debug status.
fun run_generator(base_path, is_debug){
	var write_stream = x_write(base_path + "krox.lox");
	
	if(!write_stream){
		print_error("Failed to open `krox.lox` for writing.");
		return;
	}
	
	// Add a line to the write stream.
	fun add_line(line){
		put_line(line, write_stream);
	}
	
	// Add a module to the write stream.
	fun add_module(module){
		add_line("");
		add_line(pad("// MODULE // `" + module + "` // ====", 77, "=") + " //");
		add_line("");
		
		var read_stream = x_read(base_path + module);
		
		if(!read_stream){
			print_error("Failed to open `" + module + "` for reading. File may not exist.");
			add_line("// !!! Failed to read.");
			return;
		}
		
		var char = x_get(read_stream);
		
		while(char){
			x_put(char, write_stream);
			char = x_get(read_stream);
		}
		
		if(!x_close(read_stream)){
			print_error("Failed to close `" + module + "` after reading.");
		}
	}
	
	generate_loxkrox(is_debug, add_line, add_module);
	
	if(!x_close(write_stream)){
		print_error("Failed to close `krox.lox` after writing.");
	}
}

// Run LoxKrox generator from arguments.
fun main(){
	var argument_count = x_args();
	var has_valid_arguments = false;
	var is_debug = false;
	
	if(argument_count == 1){
		has_valid_arguments = true;
	} else if(argument_count == 2 and x_arg(1) == "--debug"){
		has_valid_arguments = true;
		is_debug = true;
	}
	
	if(has_valid_arguments){
		run_generator(get_path_parent(x_arg(0)), is_debug);
	} else {
		print_error("Expected arguments `generator.lox [--debug]`.");
	}
}

main();
