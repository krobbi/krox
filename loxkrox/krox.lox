// LoxKrox
// A Krox compiler written in Lox.
// Copyright (c) 2023 Chris Roberts (Krobbizoid).
// Released under the MIT License:
// https://krobbi.github.io/license/2023/mit.txt

// This file was generated by `generator.lox`. Do not edit it directly.
// Run `generator.lox` or use `make regen` to regenerate LoxKrox from source.

// MODULE // `string/char.lox` // =========================================== //

// Character constants.
var CHAR_ILLEGAL = -2; // Unsupported character.
var CHAR_EOF = -1; // End of file.
var CHAR_TAB = 9; // Horizontal tab.
var CHAR_LINE = 10; // Line feed.
var CHAR_CR = 13; // Carriage return.
var CHAR_SPACE = x_ord(" "); // Space.
var CHAR_QUOTE = 34; // Quotation mark.
var CHAR_ASTERISK = x_ord("*"); // Asterisk.
var CHAR_SLASH = x_ord("/"); // Slash.
var CHAR_0 = x_ord("0"); // Digit 0.
var CHAR_9 = x_ord("9"); // Digit 9.
var CHAR_UPPER_A = x_ord("A"); // Uppercase letter A.
var CHAR_UPPER_Z = x_ord("Z"); // Uppercase letter Z.
var CHAR_UNDERSCORE = x_ord("_"); // Underscore.
var CHAR_LOWER_A = x_ord("a"); // Lowercase letter A.
var CHAR_LOWER_Z = x_ord("z"); // Lowercase letter Z.
var CHAR_DELETE = 127; // Delete.
var CHAR_CONTINUE_1 = 128 + 64; // UTF-8, 1 continuation byte.
var CHAR_CONTINUE_2 = 128 + 64 + 32; // UTF-8, 2 continuation bytes.
var CHAR_CONTINUE_3 = 128 + 64 + 32 + 16; // UTF-8, 3 continuation bytes.

// MODULE // `string/string.lox` // ========================================= //

// A boxed string that can be manipulated.
class String {
	// Initialize the boxed string's string.
	init(){
		// The boxed string's string.
		this.string = "";
	}
	
	// Wrap the boxed string in quotes and return the boxed string.
	quote(){
		var quote_string = x_chr(CHAR_QUOTE);
		this.string = quote_string + this.string + quote_string;
		return this;
	}
	
	// Append a string to the boxed string and return the boxed string.
	append(value){
		this.string = this.string + value;
		return this;
	}
	
	// Append an integer to the boxed string and return the boxed string.
	append_int(value){
		var formatted = "";
		
		if(value < 0){
			value = -value;
			formatted = "-";
		}
		
		var place = 10;
		
		while(place <= value){
			place = place * 10;
		}
		
		while(place >= 10){
			place = place / 10;
			var digit = x_trunc(value / place);
			value = value - digit * place;
			formatted = formatted + x_chr(CHAR_0 + digit);
		}
		
		this.string = this.string + formatted;
		return this;
	}
	
	// Return the boxed string represented as a string.
	to_string(){
		return this.string;
	}
}

// MODULE // `collections/list_node.lox` // ================================= //

// A node of a list.
class ListNode {
	// Initialize the list node's element and next list node.
	init(element){
		// The list node's element.
		this.element = element;
		
		// The list node's next list node.
		this.next = nil;
	}
}

// MODULE // `collections/list.lox` // ====================================== //

// A list of elements.
class List {
	// Initialize the list's list nodes.
	init(){
		// The list's front node.
		this.head = nil;
		
		// The list's back node.
		this.tail = nil;
	}
	
	// Clear the list.
	clear(){
		this.head = nil;
		this.tail = nil;
	}
	
	// Append an element to the back of the list.
	push_back(element){
		var node = ListNode(element);
		
		if(this.tail){
			this.tail.next = node;
		} else {
			this.head = node;
		}
		
		this.tail = node;
	}
	
	// Call a function for each element in the list.
	for_each(function){
		var node = this.head;
		
		while(node){
			function(node.element);
			node = node.next;
		}
	}
}

// MODULE // `collections/map_node.lox` // ================================== //

// A node of a map.
class MapNode {
	// Initialize the map node's key, value, and next map node.
	init(key, value, next){
		// The map node's key.
		this.key = key;
		
		// The map node's value.
		this.value = value;
		
		// The map node's next map node.
		this.next = next;
	}
}

// MODULE // `collections/map.lox` // ======================================= //

// A map of keys to values.
class Map {
	// Initialize the map's map nodes.
	init(){
		// The map's most recently created map node.
		this.head = nil;
	}
	
	// Insert a key-value pair into the map.
	insert(key, value){
		var node = this.find_node(key);
		
		if(node){
			node.value = value;
		} else {
			this.head = MapNode(key, value, this.head);
		}
	}
	
	// Return a value from the map from its key.
	get(key){
		var node = this.find_node(key);
		
		if(node){
			return node.value;
		} else {
			return nil;
		}
	}
	
	// Return a map node from its key if it exists.
	find_node(key){
		var node = this.head;
		
		while(node){
			if(node.key == key){
				return node;
			}
			
			node = node.next;
		}
		
		return nil;
	}
}

// MODULE // `logger/span.lox` // =========================================== //

// A span between two positions in a module or the lack of a span.
class Span {
	// Initialize the span's module name and positions.
	init(){
		// The span's module name.
		this.module = "";
		
		// The line number of the span's start position.
		this.start_line = 0;
		
		// The column number of the span's start position.
		this.start_column = 0;
		
		// The line number of the span's end position.
		this.end_line = 0;
		
		// The column number of the span's end position.
		this.end_column = 0;
	}
	
	// Reset the span to the start of a module from its module name.
	reset(module){
		this.module = module;
		this.start_line = 1;
		this.start_column = 1;
		this.end_line = 1;
		this.end_column = 1;
	}
	
	// Extend the span's end position from a character.
	extend_from_char(char){
		if(char == CHAR_TAB){
			this.end_column = this.end_column + 4;
		} else if(char == CHAR_LINE){
			this.end_line = this.end_line + 1;
			this.end_column = 1;
		} else if(char != CHAR_EOF and char != CHAR_CR){
			this.end_column = this.end_column + 1;
		}
	}
	
	// Shrink the span to its end position.
	shrink_to_end(){
		this.start_line = this.end_line;
		this.start_column = this.end_column;
	}
	
	// Return a new copy of the span.
	clone(){
		var target = Span();
		target.clone_from(this);
		return target;
	}
	
	// Copy the span's value from a source span.
	clone_from(source){
		this.module = source.module;
		this.start_line = source.start_line;
		this.start_column = source.start_column;
		this.end_line = source.end_line;
		this.end_column = source.end_column;
	}
	
	// Return the span represented as a string.
	to_string(){
		if(this.start_line < 1){
			return "[Global]";
		}
		
		var string = String().append_int(this.start_line).append(":").append_int(this.start_column);
		
		if(this.end_line > this.start_line){
			string.append(" > ").append_int(this.end_line).append(":").append_int(this.end_column);
		} else if(this.end_column > this.start_column){
			string.append("-").append_int(this.end_column);
		}
		
		return "[" + this.module + ":" + string.to_string() + "]";
	}
}

// MODULE // `logger/log_record.lox` // ===================================== //

// A log record containing a message and a span.
class LogRecord {
	// Initialize the log record's message and span.
	init(message, span){
		// The log record's message.
		this.message = message;
		
		// The log record's span.
		this.span = span;
	}
	
	// Return the log record represented as a string.
	to_string(){
		return this.span.to_string() + " " + this.message;
	}
}

// MODULE // `logger/logger.lox` // ========================================= //

// Logs messages at spans.
class Logger {
	// Initialize the logger's log record list.
	init(){
		// The logger's log record list.
		this.records = List();
	}
	
	// Print and clear the logger's messages.
	flush(){
		// Print a log record.
		fun print_record(record){
			print record.to_string();
		}
		
		this.records.for_each(print_record);
		this.records.clear();
	}
	
	// Log a message.
	log(message){
		this.log_at(message, Span());
	}
	
	// Log a message at a span.
	log_at(message, span){
		this.records.push_back(LogRecord(message, span.clone()));
	}
}

// MODULE // `lexer/token_type.lox` // ====================================== //

// Contains data about token types.
class TokenType {
	// Initialize the token type data.
	init(){
		// A map of token types to token type names.
		this.type_names = Map();
		
		// A map of lexemes to token types.
		this.lexeme_types = Map();
		
		var type_count = 0;
		
		// Define and return a new token type from its name or lexeme.
		fun create_type(name){
			var type = type_count;
			
			if(x_substring(name, 0, 1) == "'"){
				this.type_names.insert(type, x_substring(name, 1, x_length(name) - 2));
			} else {
				this.type_names.insert(type, "`" + name + "`");
				this.lexeme_types.insert(name, type);
			}
			
			type_count = type_count + 1;
			return type;
		}
		
		// A token type representing a syntax error, whitespace, or a comment.
		this.NONE = create_type("'non-token'");
		
		// A token type representing the end of a module.
		this.EOF = create_type("'end of file'");
		
		// A token type representing a string literal.
		this.STRING = create_type("'string'");
		
		// A token type representing an identifier.
		this.IDENTIFIER = create_type("'identifier'");
		
		// A token type representing the `fn` keyword.
		this.FN = create_type("fn");
		
		// A token type representing the `return` keyword.
		this.RETURN = create_type("return");
		
		// A token type representing the `(` lexeme.
		this.OPEN_PARENTHESIS = create_type("(");
		
		// A token type representing the `)` lexeme.
		this.CLOSE_PARENTHESIS = create_type(")");
		
		// A token type representing the `*` lexeme.
		this.STAR = create_type("*");
		
		// A token type representing the `,` lexeme.
		this.COMMA = create_type(",");
		
		// A token type representing the `/` lexeme.
		this.SLASH = create_type("/");
		
		// A token type representing the `;` lexeme.
		this.SEMICOLON = create_type(";");
		
		// A token type representing the `<` lexeme.
		this.LESS = create_type("<");
		
		// A token type representing the `>` lexeme.
		this.GREATER = create_type(">");
		
		// A token type representing the `{` lexeme.
		this.OPEN_BRACE = create_type("{");
		
		// A token type representing the `}` lexeme.
		this.CLOSE_BRACE = create_type("}");
	}
	
	// Return a token type's name.
	get_name(type){
		return this.type_names.get(type);
	}
	
	// Return a token type from a lexeme.
	from_lexeme(lexeme){
		return this.lexeme_types.get(lexeme);
	}
}

// The token type data singleton.
var TokenType = TokenType();

// MODULE // `lexer/token.lox` // =========================================== //

// Contains a lexeme's data.
class Token {
	// Initialize the token's type, value, and span.
	init(type, value, span){
		// The token's type.
		this.type = type;
		
		// The token's value.
		this.value = value;
		
		// The token's span.
		this.span = span;
	}
	
	// Return the token represented as a string.
	to_string(){
		var literal = nil;
		
		if(this.type == TokenType.STRING){
			literal = String().append(this.value).quote().to_string();
		} else if(this.type == TokenType.IDENTIFIER){
			literal = this.value;
		}
		
		var name = TokenType.get_name(this.type);
		
		if(literal){
			return name + " `" + literal + "`";
		} else {
			return name;
		}
	}
	
	// Return the token represented as a string for debugging.
	to_debug_string(){
		return "(" + this.span.to_string() + ", " + this.to_string() + ")";
	}
}

// MODULE // `lexer/lexer.lox` // =========================================== //

// Scans a stream of tokens from an input stream.
class Lexer {
	// Initialize the lexer's logger, span, input stream, and next character.
	init(logger){
		// The lexer's logger.
		this.logger = logger;
		
		// The lexer's span.
		this.span = Span();
		
		// The lexer's input stream.
		this.stream = -1;
		
		// The lexer's next character.
		this.next = CHAR_EOF;
	}
	
	// Reset the lexer from a module name and an input stream.
	reset(module, stream){
		this.span.reset(module);
		this.stream = stream;
		this.next = CHAR_EOF;
		this.advance();
	}
	
	// Return the next token from the lexer.
	scan_token(){
		var token = this.scan_raw_token();
		
		while(token.type == TokenType.NONE){
			token = this.scan_raw_token();
		}
		
		return token;
	}
	
	// Return the next token or none token from the lexer.
	scan_raw_token(){
		// Return whether a character is an alphabetical character.
		fun is_alpha(char){
			return (
				char >= CHAR_LOWER_A and char <= CHAR_LOWER_Z
				or char == CHAR_UNDERSCORE
				or char >= CHAR_UPPER_A and char <= CHAR_UPPER_Z
			);
		}
		
		// Return whether the next character matches a predicate.
		fun match(predicate){
			return predicate(this.next);
		}
		
		// Advance if the next character matches a character.
		fun accept(char){
			if(this.next == char){
				this.advance();
				return true;
			} else {
				return false;
			}
		}
		
		// Return a new token at the current span from its type and value.
		fun make_literal_token(type, value){
			return Token(type, value, this.span.clone());
		}
		
		// Return a new token at the current span from its type.
		fun make_token(type){
			return make_literal_token(type, nil);
		}
		
		// Log an error message at the current span.
		fun error(message){
			this.logger.log_at(message, this.span);
		}
		
		this.span.shrink_to_end();
		
		if(this.next == CHAR_EOF){
			return make_token(TokenType.EOF);
		} else if(accept(CHAR_ILLEGAL)){
			return make_token(TokenType.NONE);
		} else if(match(this.is_whitespace)){
			this.advance();
			
			while(match(this.is_whitespace)){
				this.advance();
			}
			
			return make_token(TokenType.NONE);
		} else if(accept(CHAR_SLASH)){
			if(accept(CHAR_SLASH)){
				// Return whether a character is a line comment terminator.
				fun is_line_comment_terminator(char){
					return char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR;
				}
				
				while(!match(is_line_comment_terminator)){
					this.advance();
				}
				
				return make_token(TokenType.NONE);
			} else {
				return make_token(TokenType.SLASH);
			}
		} else if(accept(CHAR_QUOTE)){
			// Return whether a character is a string terminator.
			fun is_string_terminator(char){
				return (
					char == CHAR_QUOTE or char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR
				);
			}
			
			var value = "";
			
			while(!match(is_string_terminator)){
				value = value + x_chr(this.advance());
			}
			
			if(!accept(CHAR_QUOTE)){
				error("Unterminated string.");
			}
			
			return make_literal_token(TokenType.STRING, value);
		} else if(match(is_alpha)){
			// Return whether a character is an alphanumeric characteer.
			fun is_alphanumeric(char){
				return is_alpha(char) or char >= CHAR_0 and char <= CHAR_9;
			}
			
			var value = x_chr(this.advance());
			
			while(match(is_alphanumeric)){
				value = value + x_chr(this.advance());
			}
			
			var type = TokenType.from_lexeme(value);
			
			if(type){
				return make_token(type);
			} else {
				return make_literal_token(TokenType.IDENTIFIER, value);
			}
		} else {
			var lexeme = x_chr(this.advance());
			var type = TokenType.from_lexeme(lexeme);
			
			if(type){
				return make_token(type);
			}
			
			error("Illegal character `" + lexeme + "`.");
			return make_token(TokenType.NONE);
		}
	}
	
	// Return whether a character is a whitespace character.
	is_whitespace(char){
		return char == CHAR_SPACE or char == CHAR_TAB or char == CHAR_LINE or char == CHAR_CR;
	}
	
	// Advance to the next character and return the new current character.
	advance(){
		// Log an error message and return an illegal character.
		fun illegal(message){
			var error_span = this.span.clone();
			error_span.shrink_to_end();
			error_span.extend_from_char(CHAR_ILLEGAL);
			this.logger.log_at(message, error_span);
			return CHAR_ILLEGAL;
		}
		
		var current = this.next;
		this.span.extend_from_char(current);
		var next = x_get(this.stream);
		
		if(!next){
			x_close(this.stream);
			next = CHAR_EOF;
		} else if(next == CHAR_DELETE or next < CHAR_SPACE and !this.is_whitespace(next)){
			next = illegal("Krox source cannot contain control characters.");
		} else if(next > CHAR_DELETE){
			var skip_count = 0;
			
			if(next >= CHAR_CONTINUE_3){
				skip_count = 3;
			} else if(next >= CHAR_CONTINUE_2){
				skip_count = 2;
			} else if(next >= CHAR_CONTINUE_1){
				skip_count = 1;
			}
			
			// Assume UTF-8, skip continuation bytes.
			while(skip_count > 0){
				next = x_get(this.stream);
				skip_count = skip_count - 1;
				
				if(!next){
					x_close(this.stream);
					skip_count = 0;
				}
			}
			
			next = illegal("Krox source cannot contain non-ASCII characters.");
		}
		
		this.next = next;
		return current;
	}
}

// MODULE // `core/main.lox` // ============================================= //

// Test the lexer from a path and a logger.
fun test_lexer(path, logger){
	var stream = x_read(path);
	
	if(!stream){
		logger.log("Failed to open `" + path + "` for reading. File may not exist.");
		return;
	}
	
	var lexer = Lexer(logger);
	lexer.reset(path, stream);
	var token = lexer.scan_token();
	print token.to_debug_string();
	
	while(token.type != TokenType.EOF){
		token = lexer.scan_token();
		print token.to_debug_string();
	}
	
	if(x_close(stream)){
		logger.log("Lexer failed to close `" + path + "` after reading.");
	}
}

// Run the compiler.
fun main(){
	var logger = Logger();
	
	if(x_args() == 2){
		test_lexer(x_arg(1), logger);
	} else {
		logger.log("Expected arguments `krox.lox <krox source path>`.");
	}
	
	logger.flush();
}

main();
