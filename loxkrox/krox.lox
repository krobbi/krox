// LoxKrox
// A Krox compiler written in Lox.
// Copyright (c) 2023 Chris Roberts (Krobbizoid).
// Released under the MIT License:
// https://krobbi.github.io/license/2023/mit.txt

// This file was generated by `generator.lox`. Do not edit it directly.
// Run `generator.lox` or use `make regen` to regenerate LoxKrox from source.

// MODULE // `string/char.lox` // =========================================== //

// Character constants.
var CHAR_ILLEGAL = -2; // Unsupported character.
var CHAR_EOF = -1; // End of file.
var CHAR_TAB = 9; // Horizontal tab.
var CHAR_LINE = 10; // Line feed.
var CHAR_CR = 13; // Carriage return.
var CHAR_SPACE = x_ord(" "); // Space.
var CHAR_QUOTE = 34; // Quotation mark.
var CHAR_APOSTROPHE = x_ord("'"); // Apostrophe.
var CHAR_ASTERISK = x_ord("*"); // Asterisk.
var CHAR_SLASH = x_ord("/"); // Slash.
var CHAR_0 = x_ord("0"); // Digit 0.
var CHAR_9 = x_ord("9"); // Digit 9.
var CHAR_UPPER_A = x_ord("A"); // Uppercase letter A.
var CHAR_UPPER_Z = x_ord("Z"); // Uppercase letter Z.
var CHAR_BACKSLASH = x_ord("\"); // Backslash.
var CHAR_UNDERSCORE = x_ord("_"); // Underscore.
var CHAR_LOWER_A = x_ord("a"); // Lowercase letter A.
var CHAR_LOWER_N = x_ord("n"); // Lowercase letter N.
var CHAR_LOWER_R = x_ord("r"); // Lowercase letter R.
var CHAR_LOWER_T = x_ord("t"); // Lowercase letter T.
var CHAR_LOWER_Z = x_ord("z"); // Lowercase letter Z.
var CHAR_DELETE = 127; // Delete.
var CHAR_CONTINUE_1 = 128 + 64; // UTF-8, 1 continuation byte.
var CHAR_CONTINUE_2 = 128 + 64 + 32; // UTF-8, 2 continuation bytes.
var CHAR_CONTINUE_3 = 128 + 64 + 32 + 16; // UTF-8, 3 continuation bytes.

// MODULE // `string/string.lox` // ========================================= //

// A boxed string that can be manipulated.
class String {
	// Initialize the boxed string's string.
	init(){
		// The boxed string's string.
		this.string = "";
	}
	
	// Wrap the boxed string in quotes and return the boxed string.
	quote(){
		var quote_string = x_chr(CHAR_QUOTE);
		var length = x_length(this.string);
		var escaped = "";
		
		for(var i = 0; i < length; i = i + 1){
			var char_string = x_substring(this.string, i, 1);
			var char = x_ord(char_string);
			
			if(char == CHAR_TAB){
				escaped = escaped + "\t";
			} else if(char == CHAR_LINE){
				escaped = escaped + "\n";
			} else if(char == CHAR_CR){
				escaped = escaped + "\r";
			} else if(char == CHAR_QUOTE){
				escaped = escaped + "\" + quote_string;
			} else if(char == CHAR_APOSTROPHE){
				escaped = escaped + "\'";
			} else if(char == CHAR_BACKSLASH){
				escaped = escaped + "\\";
			} else {
				escaped = escaped + char_string;
			}
		}
		
		this.string = quote_string + escaped + quote_string;
		return this;
	}
	
	// Append a string to the boxed string and return the boxed string.
	append(value){
		this.string = this.string + value;
		return this;
	}
	
	// Append an integer to the boxed string and return the boxed string.
	append_int(value){
		var formatted = "";
		
		if(value < 0){
			value = -value;
			formatted = "-";
		}
		
		var place = 10;
		
		while(place <= value){
			place = place * 10;
		}
		
		while(place >= 10){
			place = place / 10;
			var digit = x_trunc(value / place);
			value = value - digit * place;
			formatted = formatted + x_chr(CHAR_0 + digit);
		}
		
		this.string = this.string + formatted;
		return this;
	}
	
	// Put the boxed string to an output stream with a trailing line feed.
	put_line(stream){
		var length = x_length(this.string);
		
		for(var i = 0; i < length; i = i + 1){
			x_put(x_ord(x_substring(this.string, i, 1)), stream);
		}
		
		x_put(CHAR_LINE, stream);
	}
	
	// Return the boxed string represented as a string.
	to_string(){
		return this.string;
	}
}

// MODULE // `collections/list_node.lox` // ================================= //

// A node of a list.
class ListNode {
	// Initialize the list node's element and list nodes.
	init(element, previous){
		// The list node's element.
		this.element = element;
		
		// The list node's previous list node.
		this.previous = previous;
		
		// The list node's next list node.
		this.next = nil;
	}
}

// MODULE // `collections/list_iterator.lox` // ============================= //

// An iterator for a list.
class ListIterator {
	// Initialize the list iterator's next list node.
	init(next_node){
		// The list iterator's next list node.
		this.next_node = next_node;
	}
	
	// Return whether the list iterator has a next element.
	has_next(){
		return this.next_node != nil;
	}
	
	// Return the list iterator's next element.
	get_next(){
		var node = this.next_node;
		
		if(!node){
			return nil;
		}
		
		this.next_node = node.next;
		return node.element;
	}
}

// MODULE // `collections/list.lox` // ====================================== //

// A list of elements.
class List {
	// Initialize the list's list nodes and length.
	init(){
		// The list's front node.
		this.head = nil;
		
		// The list's back node.
		this.tail = nil;
		
		// The list's length.
		this.length = 0;
	}
	
	// Clear the list.
	clear(){
		this.head = nil;
		this.tail = nil;
		this.length = 0;
	}
	
	// Return the list's length.
	get_length(){
		return this.length;
	}
	
	// Append an element to the back of the list.
	push_back(element){
		var node = ListNode(element, this.tail);
		
		if(node.previous){
			node.previous.next = node;
		} else {
			this.head = node;
		}
		
		this.tail = node;
		this.length = this.length + 1;
	}
	
	// Remove and return an element from the back of the list.
	pop_back(){
		var node = this.tail;
		
		if(!node){
			return nil;
		}
		
		if(node.previous){
			node.previous.next = nil;
			this.tail = node.previous;
			this.length = this.length - 1;
		} else {
			this.clear();
		}
		
		return node.element;
	}
	
	// Return a new list iterator for the list.
	iter(){
		return ListIterator(this.head);
	}
	
	// Call a function for each element in the list.
	for_each(function){
		var node = this.head;
		
		while(node){
			function(node.element);
			node = node.next;
		}
	}
}

// MODULE // `collections/map_node.lox` // ================================== //

// A node of a map.
class MapNode {
	// Initialize the map node's key, value, and next map node.
	init(key, value, next){
		// The map node's key.
		this.key = key;
		
		// The map node's value.
		this.value = value;
		
		// The map node's next map node.
		this.next = next;
	}
}

// MODULE // `collections/map.lox` // ======================================= //

// A map of keys to values.
class Map {
	// Initialize the map's map nodes.
	init(){
		// The map's most recently created map node.
		this.head = nil;
	}
	
	// Insert a key-value pair into the map.
	insert(key, value){
		var node = this.find_node(key);
		
		if(node){
			node.value = value;
		} else {
			this.head = MapNode(key, value, this.head);
		}
	}
	
	// Return a value from the map from its key.
	get(key){
		var node = this.find_node(key);
		
		if(node){
			return node.value;
		} else {
			return nil;
		}
	}
	
	// Return a map node from its key if it exists.
	find_node(key){
		var node = this.head;
		
		while(node){
			if(node.key == key){
				return node;
			}
			
			node = node.next;
		}
		
		return nil;
	}
}

// MODULE // `logger/span.lox` // =========================================== //

// A span between two positions in a module or the lack of a span.
class Span {
	// Initialize the span's module name and positions.
	init(){
		// The span's module name.
		this.module = "";
		
		// The line number of the span's start position.
		this.start_line = 0;
		
		// The column number of the span's start position.
		this.start_column = 0;
		
		// The line number of the span's end position.
		this.end_line = 0;
		
		// The column number of the span's end position.
		this.end_column = 0;
	}
	
	// Reset the span to the start of a module from its module name.
	reset(module){
		this.module = module;
		this.start_line = 1;
		this.start_column = 1;
		this.end_line = 1;
		this.end_column = 1;
	}
	
	// Extend the span's end position from a character.
	extend_from_char(char){
		if(char == CHAR_TAB){
			this.end_column = this.end_column + 4;
		} else if(char == CHAR_LINE){
			this.end_line = this.end_line + 1;
			this.end_column = 1;
		} else if(char != CHAR_EOF and char != CHAR_CR){
			this.end_column = this.end_column + 1;
		}
	}
	
	// Extend the span's end position from a span.
	extend_from_span(span){
		this.end_line = span.end_line;
		this.end_column = span.end_column;
	}
	
	// Shrink the span to its end position.
	shrink_to_end(){
		this.start_line = this.end_line;
		this.start_column = this.end_column;
	}
	
	// Return a new copy of the span.
	clone(){
		var target = Span();
		target.clone_from(this);
		return target;
	}
	
	// Copy the span's value from a source span.
	clone_from(source){
		this.module = source.module;
		this.start_line = source.start_line;
		this.start_column = source.start_column;
		this.end_line = source.end_line;
		this.end_column = source.end_column;
	}
	
	// Return the span represented as a string.
	to_string(){
		if(this.start_line < 1){
			return "[Global]";
		}
		
		var string = String().append_int(this.start_line).append(":").append_int(this.start_column);
		
		if(this.end_line > this.start_line){
			string.append(" > ").append_int(this.end_line).append(":").append_int(this.end_column);
		} else if(this.end_column > this.start_column){
			string.append("-").append_int(this.end_column);
		}
		
		return "[" + this.module + ":" + string.to_string() + "]";
	}
}

// MODULE // `logger/log_record.lox` // ===================================== //

// A log record containing a message and a span.
class LogRecord {
	// Initialize the log record's message and span.
	init(message, span){
		// The log record's message.
		this.message = message;
		
		// The log record's span.
		this.span = span;
	}
	
	// Return the log record represented as a string.
	to_string(){
		return this.span.to_string() + " " + this.message;
	}
}

// MODULE // `logger/logger.lox` // ========================================= //

// Logs messages at spans.
class Logger {
	// Initialize the logger's log record list.
	init(){
		// The logger's log record list.
		this.records = List();
	}
	
	// Output and clear the logger's messages.
	flush(){
		var iter = this.records.iter();
		var stream = x_stderr();
		
		while(iter.has_next()){
			String().append(iter.get_next().to_string()).put_line(stream);
		}
		
		this.records.clear();
	}
	
	// Log a message.
	log(message){
		this.log_at(message, Span());
	}
	
	// Log a message at a span.
	log_at(message, span){
		this.records.push_back(LogRecord(message, span.clone()));
	}
}

// MODULE // `lexer/token_type.lox` // ====================================== //

// Contains data about token types.
class TokenType {
	// Initialize the token type data.
	init(){
		// A map of token types to token type names.
		this.type_names = Map();
		
		// A map of lexemes to token types.
		this.lexeme_types = Map();
		
		var type_count = 0;
		
		// Define and return a new token type from its name or lexeme.
		fun create_type(name){
			var type = type_count;
			
			if(x_substring(name, 0, 1) == "'"){
				this.type_names.insert(type, x_substring(name, 1, x_length(name) - 2));
			} else {
				this.type_names.insert(type, "`" + name + "`");
				this.lexeme_types.insert(name, type);
			}
			
			type_count = type_count + 1;
			return type;
		}
		
		// A token type representing a syntax error, whitespace, or a comment.
		this.NONE = create_type("'non-token'");
		
		// A token type representing the end of a module.
		this.EOF = create_type("'end of file'");
		
		// A token type representing a string literal.
		this.STRING = create_type("'string'");
		
		// A token type representing an identifier.
		this.IDENTIFIER = create_type("'identifier'");
		
		// A token type representing the `,` lexeme.
		this.COMMA = create_type(",");
		
		// A token type representing the `>` lexeme.
		this.GREATER = create_type(">");
		
		// A token type representing the `{` lexeme.
		this.OPEN_BRACE = create_type("{");
		
		// A token type representing the `}` lexeme.
		this.CLOSE_BRACE = create_type("}");
	}
	
	// Return a token type's name.
	get_name(type){
		return this.type_names.get(type);
	}
	
	// Return a token type from a lexeme.
	from_lexeme(lexeme){
		return this.lexeme_types.get(lexeme);
	}
}

// The token type data singleton.
var TokenType = TokenType();

// MODULE // `lexer/token.lox` // =========================================== //

// Contains a lexeme's data.
class Token {
	// Initialize the token's type, value, and span.
	init(type, value, span){
		// The token's type.
		this.type = type;
		
		// The token's value.
		this.value = value;
		
		// The token's span.
		this.span = span;
	}
	
	// Return the token represented as a string.
	to_string(){
		var literal = nil;
		
		if(this.type == TokenType.STRING){
			literal = String().append(this.value).quote().to_string();
		} else if(this.type == TokenType.IDENTIFIER){
			literal = this.value;
		}
		
		var name = TokenType.get_name(this.type);
		
		if(literal){
			return name + " `" + literal + "`";
		} else {
			return name;
		}
	}
}

// MODULE // `lexer/lexer.lox` // =========================================== //

// Scans a stream of tokens from an input stream.
class Lexer {
	// Initialize the lexer's logger, span, input stream, and next character.
	init(logger){
		// The lexer's logger.
		this.logger = logger;
		
		// The lexer's span.
		this.span = Span();
		
		// The lexer's input stream.
		this.stream = -1;
		
		// The lexer's next character.
		this.next = CHAR_EOF;
	}
	
	// Reset the lexer from a module name and an input stream.
	reset(module, stream){
		this.span.reset(module);
		this.stream = stream;
		this.next = CHAR_EOF;
		this.advance();
	}
	
	// Return the next token from the lexer.
	scan_token(){
		var token = this.scan_raw_token();
		
		while(token.type == TokenType.NONE){
			token = this.scan_raw_token();
		}
		
		return token;
	}
	
	// Return the next token or none token from the lexer.
	scan_raw_token(){
		// Return whether a character is an alphabetical character.
		fun is_alpha(char){
			return (
				char >= CHAR_LOWER_A and char <= CHAR_LOWER_Z
				or char == CHAR_UNDERSCORE
				or char >= CHAR_UPPER_A and char <= CHAR_UPPER_Z
			);
		}
		
		// Return whether the next character matches a predicate.
		fun match(predicate){
			return predicate(this.next);
		}
		
		// Advance if the next character matches a character.
		fun accept(char){
			if(this.next == char){
				this.advance();
				return true;
			} else {
				return false;
			}
		}
		
		// Return a new token at the current span from its type and value.
		fun make_literal_token(type, value){
			return Token(type, value, this.span.clone());
		}
		
		// Return a new token at the current span from its type.
		fun make_token(type){
			return make_literal_token(type, nil);
		}
		
		// Log an error message at the current span.
		fun error(message){
			this.logger.log_at(message, this.span);
		}
		
		this.span.shrink_to_end();
		
		if(this.next == CHAR_EOF){
			return make_token(TokenType.EOF);
		} else if(accept(CHAR_ILLEGAL)){
			return make_token(TokenType.NONE);
		} else if(match(this.is_whitespace)){
			this.advance();
			
			while(match(this.is_whitespace)){
				this.advance();
			}
			
			return make_token(TokenType.NONE);
		} else if(accept(CHAR_SLASH)){
			if(accept(CHAR_ASTERISK)){
				var depth = 1;
				
				while(depth > 0 and this.next != CHAR_EOF){
					if(accept(CHAR_ASTERISK)){
						if(accept(CHAR_SLASH)){
							depth = depth - 1;
						}
					} else if(accept(CHAR_SLASH)){
						if(accept(CHAR_ASTERISK)){
							depth = depth + 1;
						}
					} else {
						this.advance();
					}
				}
				
				if(depth > 0){
					error("Unterminated block comment.");
				}
				
				return make_token(TokenType.NONE);
			} else if(accept(CHAR_SLASH)){
				// Return whether a character is a line comment terminator.
				fun is_line_comment_terminator(char){
					return char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR;
				}
				
				while(!match(is_line_comment_terminator)){
					this.advance();
				}
				
				return make_token(TokenType.NONE);
			} else {
				error("Illegal character `/`.");
				return make_token(TokenType.NONE);
			}
		} else if(accept(CHAR_QUOTE)){
			// Return whether a character is a string terminator.
			fun is_string_terminator(char){
				return (
					char == CHAR_QUOTE or char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR
				);
			}
			
			var value = "";
			
			while(!match(is_string_terminator)){
				if(accept(CHAR_BACKSLASH)){
					if(accept(CHAR_QUOTE)){
						value = value + x_chr(CHAR_QUOTE);
					} else if(accept(CHAR_APOSTROPHE)){
						value = value + "'";
					} else if(accept(CHAR_BACKSLASH)){
						value = value + "\";
					} else if(accept(CHAR_LOWER_N)){
						value = value + x_chr(CHAR_LINE);
					} else if(accept(CHAR_LOWER_R)){
						value = value + x_chr(CHAR_CR);
					} else if(accept(CHAR_LOWER_T)){
						value = value + x_chr(CHAR_TAB);
					} else {
						var error_span = this.span.clone();
						error_span.shrink_to_end();
						
						if(this.next == CHAR_EOF){
							this.logger.log_at("Expected escape character after `\`.", error_span);
						} else {
							error_span.extend_from_char(this.advance());
							this.logger.log_at("Illegal escape character.", error_span);
						}
					}
				} else {
					value = value + x_chr(this.advance());
				}
			}
			
			if(!accept(CHAR_QUOTE)){
				error("Unterminated string.");
			}
			
			return make_literal_token(TokenType.STRING, value);
		} else if(match(is_alpha)){
			// Return whether a character is an alphanumeric characteer.
			fun is_alphanumeric(char){
				return is_alpha(char) or char >= CHAR_0 and char <= CHAR_9;
			}
			
			var value = x_chr(this.advance());
			
			while(match(is_alphanumeric)){
				value = value + x_chr(this.advance());
			}
			
			var type = TokenType.from_lexeme(value);
			
			if(type){
				return make_token(type);
			} else {
				return make_literal_token(TokenType.IDENTIFIER, value);
			}
		} else {
			var lexeme = x_chr(this.advance());
			var type = TokenType.from_lexeme(lexeme);
			
			if(type){
				return make_token(type);
			}
			
			error("Illegal character `" + lexeme + "`.");
			return make_token(TokenType.NONE);
		}
	}
	
	// Return whether a character is a whitespace character.
	is_whitespace(char){
		return char == CHAR_SPACE or char == CHAR_TAB or char == CHAR_LINE or char == CHAR_CR;
	}
	
	// Advance to the next character and return the new current character.
	advance(){
		// Log an error message and return an illegal character.
		fun illegal(message){
			var error_span = this.span.clone();
			error_span.shrink_to_end();
			error_span.extend_from_char(CHAR_ILLEGAL);
			this.logger.log_at(message, error_span);
			return CHAR_ILLEGAL;
		}
		
		var current = this.next;
		this.span.extend_from_char(current);
		var next = x_get(this.stream);
		
		if(!next){
			x_close(this.stream);
			next = CHAR_EOF;
		} else if(next == CHAR_DELETE or next < CHAR_SPACE and !this.is_whitespace(next)){
			next = illegal("Krox source cannot contain control characters.");
		} else if(next > CHAR_DELETE){
			var skip_count = 0;
			
			if(next >= CHAR_CONTINUE_3){
				skip_count = 3;
			} else if(next >= CHAR_CONTINUE_2){
				skip_count = 2;
			} else if(next >= CHAR_CONTINUE_1){
				skip_count = 1;
			}
			
			// Assume UTF-8, skip continuation bytes.
			while(skip_count > 0){
				next = x_get(this.stream);
				skip_count = skip_count - 1;
				
				if(!next){
					x_close(this.stream);
					skip_count = 0;
				}
			}
			
			next = illegal("Krox source cannot contain non-ASCII characters.");
		}
		
		this.next = next;
		return current;
	}
}

// MODULE // `ast/ast_node.lox` // ========================================== //

// A node of an abstract syntax tree.
class ASTNode {
	// Initialize the AST node's span.
	init(){
		// The AST node's span.
		this.span = Span();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return nil;
	}
}

// MODULE // `ast/nodes/import_ast_node.lox` // ============================= //

// An import node of an abstract syntax tree.
class ImportASTNode < ASTNode {
	// Initialize the import AST node's path token and import item list.
	init(path){
		super.init();
		
		// The import AST node's path token.
		this.path = path;
		
		// The import AST node's import item list.
		this.items = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_import(this);
	}
}

// MODULE // `ast/nodes/import_item_ast_node.lox` // ======================== //

// An import item node of an AST.
class ImportItemASTNode < ASTNode {
	// Initialize the import item AST node's identifier tokens.
	init(external, internal){
		super.init();
		
		// The import item AST node's external identifier token.
		this.external = external;
		
		// The import item AST node's optional internal identifier token.
		this.internal = internal;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_import_item(this);
	}
}

// MODULE // `ast/nodes/module_ast_node.lox` // ============================= //

// A module node of an abstract syntax tree.
class ModuleASTNode < ASTNode {
	// Initialize the module AST node's import list.
	init(){
		super.init();
		
		// The module AST node's import list.
		this.imports = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_module(this);
	}
}

// MODULE // `ast/ast_visitor.lox` // ======================================= //

// Visits AST nodes and returns values for each type of AST node.
class ASTVisitor {
	// Initialize the AST visitor.
	init(){}
	
	// Visit an AST node and return a value.
	visit(node){
		return node.accept_visitor(this);
	}
	
	// Visit an import AST node and return a value.
	visit_import(node){
		return nil;
	}
	
	// Visit an import item AST node and return a value.
	visit_import_item(node){
		return nil;
	}
	
	// Visit a module AST node and return a value.
	visit_module(node){
		return nil;
	}
}

// MODULE // `ast/printer/ast_printer_node.lox` // ========================== //

// A generic tree node for printing an AST.
class ASTPrinterNode {
	// Initialize the AST printer node's message and child array.
	init(message){
		// The AST printer node's message.
		this.message = message;
		
		// The AST printer node's child array.
		this.children = List();
	}
	
	// Append an AST printer node to the AST printer node's children.
	append(node){
		this.children.push_back(node);
	}
	
	// Recursively print the AST printer node and its children.
	print_node(flags){
		var iter = flags.iter();
		var prefix = "";
		
		while(iter.has_next()){
			var flag = iter.get_next();
			
			if(iter.has_next()){
				if(flag){
					prefix = prefix + "|  ";
				} else {
					prefix = prefix + "   ";
				}
			} else {
				if(flag){
					prefix = prefix + "|--";
				} else {
					prefix = prefix + "|__";
				}
			}
		}
		
		print prefix + this.message;
		iter = this.children.iter();
		
		while(iter.has_next()){
			var child = iter.get_next();
			flags.push_back(iter.has_next());
			child.print_node(flags);
			flags.pop_back();
		}
	}
}

// MODULE // `ast/printer/ast_printer.lox` // =============================== //

// An AST visitor that prints an AST.
class ASTPrinter < ASTVisitor {
	// Initialize the AST printer's current AST printer node.
	init(){
		super.init();
		
		// The AST printer's current AST printer node.
		this.current = nil;
	}
	
	// Print an AST from its root node.
	print_ast(node){
		this.visit(node).print_node(List());
	}
	
	// Begin a new current AST printer node from a name and an AST node.
	begin(name, node){
		this.current = ASTPrinterNode("(" + name + ") " + node.span.to_string());
	}
	
	// Append an AST node to the current AST printer node.
	append_node(node){
		var current = this.current;
		current.append(this.visit(node));
		this.current = current;
	}
	
	// Append a token to the current AST printer node from a name.
	append_token(name, token){
		var message = "{" + name + ": ";
		
		if(token.type == TokenType.STRING){
			message = message + String().append(token.value).quote().to_string();
		} else if(token.type == TokenType.IDENTIFIER){
			message = message + token.value;
		} else {
			message = message + token.to_string();
		}
		
		this.current.append(ASTPrinterNode(message + "} " + token.span.to_string()));
	}
	
	// End and return the current AST printer node.
	end(){
		var current = this.current;
		this.current = nil;
		return current;
	}
	
	// Visit an import AST node and return an AST printer node.
	visit_import(node){
		this.begin("Import", node);
		this.append_token("path", node.path);
		node.items.for_each(this.append_node);
		return this.end();
	}
	
	// Visit an import item AST node and return an AST printer node.
	visit_import_item(node){
		this.begin("ImportItem", node);
		this.append_token("external", node.external);
		
		if(node.internal){
			this.append_token("internal", node.internal);
		}
		
		return this.end();
	}
	
	// Visit a module AST node and return an AST printer node.
	visit_module(node){
		this.begin("Module", node);
		node.imports.for_each(this.append_node);
		return this.end();
	}
}

// MODULE // `parser/parser.lox` // ========================================= //

// Parses an abstract syntax tree from a stream of tokens.
class Parser {
	// Initialize the parser's logger, lexer, and data.
	init(logger){
		// The parser's logger.
		this.logger = logger;
		
		// The parser's lexer.
		this.lexer = Lexer(logger);
		
		// The parser's next token.
		this.next = Token(TokenType.EOF, nil, Span());
		
		// The parser's current span.
		this.current_span = Span();
		
		// The parser's span stack.
		this.span_stack = List();
	}
	
	// Reset the parser from a module name and an input stream.
	reset(module, stream){
		this.lexer.reset(module, stream);
		this.advance();
	}
	
	// Parse and return a module AST node.
	parse_module(){
		this.begin();
		var module = ModuleASTNode();
		
		while(!this.match(TokenType.EOF)){
			var bump_token = this.next;
			var import = this.parse_import();
			
			if(import){
				module.imports.push_back(import);
			}
			
			if(this.next == bump_token){
				this.advance(); // Prevent infinite loop.
			}
		}
		
		return this.end(module);
	}
	
	// Parse and return an import AST node if possible.
	parse_import(){
		this.begin();
		this.expect(TokenType.GREATER);
		var import = ImportASTNode(this.expect(TokenType.STRING));
		
		if(!import.path){
			return this.end(nil);
		}
		
		this.expect(TokenType.OPEN_BRACE);
		var accepts_item = true;
		
		while(accepts_item and !this.match(TokenType.CLOSE_BRACE) and !this.match(TokenType.EOF)){
			var import_item = this.parse_import_item();
			
			if(import_item){
				import.items.push_back(import_item);
			}
			
			if(!this.accept(TokenType.COMMA)){
				accepts_item = false;
			}
		}
		
		this.expect(TokenType.CLOSE_BRACE);
		return this.end(import);
	}
	
	// Parse and return an import item AST node if possible.
	parse_import_item(){
		this.begin();
		var external = this.expect(TokenType.IDENTIFIER);
		
		if(!external){
			return this.end(nil);
		}
		
		var internal = nil;
		
		if(this.accept(TokenType.GREATER)){
			internal = this.expect(TokenType.IDENTIFIER);
		}
		
		return this.end(ImportItemASTNode(external, internal));
	}
	
	// Begin an AST node.
	begin(){
		this.span_stack.push_back(this.next.span);
	}
	
	// End and return an AST node.
	end(node){
		if(node){
			node.span.clone_from(this.span_stack.pop_back());
			node.span.extend_from_span(this.current_span);
		}
		
		return node;
	}
	
	// Return whether the next token matches a token type.
	match(type){
		return this.next.type == type;
	}
	
	// Consume and return the next token if it matches a type.
	accept(type){
		if(this.match(type)){
			return this.advance();
		} else {
			return nil;
		}
	}
	
	// Consume and return the next token if it matches a type or log an error.
	expect(type){
		var consumed = this.accept(type);
		
		if(!consumed){
			this.logger.log_at(
				"Expected " + TokenType.get_name(type) + ", got " + this.next.to_string() + ".",
				this.next.span
			);
		}
		
		return consumed;
	}
	
	// Advance to the next token and return the new current token.
	advance(){
		var current = this.next;
		this.current_span = current.span;
		this.next = this.lexer.scan_token();
		return current;
	}
}

// MODULE // `core/main.lox` // ============================================= //

// Test the parser from a path and a logger.
fun test_parser(path, logger){
	var stream = x_read(path);
	
	if(!stream){
		logger.log("Failed to open `" + path + "` for reading. File may not exist.");
		return;
	}
	
	var parser = Parser(logger);
	parser.reset(path, stream);
	ASTPrinter().print_ast(parser.parse_module());
	
	if(x_close(stream)){
		logger.log("Parser failed to close `" + path + "` after reading.");
	}
}

// Run the compiler.
fun main(){
	var logger = Logger();
	
	if(x_args() == 2){
		test_parser(x_arg(1), logger);
	} else {
		logger.log("Expected arguments `krox.lox <krox source path>`.");
	}
	
	logger.flush();
}

main();
