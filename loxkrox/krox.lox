// LoxKrox
// A Krox compiler written in Lox.
// Copyright (c) 2023 Chris Roberts (Krobbizoid).
// Released under the MIT License:
// https://krobbi.github.io/license/2023/mit.txt

// This file was generated by `generator.lox`. Do not edit it directly.
// Run `generator.lox` or use `make regen` to regenerate LoxKrox from source.

// MODULE // `string/char.lox` // =========================================== //

// Character constants.
var CHAR_ILLEGAL = -2; // Unsupported character.
var CHAR_EOF = -1; // End of file.
var CHAR_TAB = 9; // Horizontal tab.
var CHAR_LINE = 10; // Line feed.
var CHAR_CR = 13; // Carriage return.
var CHAR_SPACE = x_ord(" "); // Space.
var CHAR_QUOTE = 34; // Quotation mark.
var CHAR_APOSTROPHE = x_ord("'"); // Apostrophe.
var CHAR_ASTERISK = x_ord("*"); // Asterisk.
var CHAR_SLASH = x_ord("/"); // Slash.
var CHAR_0 = x_ord("0"); // Digit 0.
var CHAR_9 = x_ord("9"); // Digit 9.
var CHAR_UPPER_A = x_ord("A"); // Uppercase letter A.
var CHAR_UPPER_Z = x_ord("Z"); // Uppercase letter Z.
var CHAR_BACKSLASH = x_ord("\"); // Backslash.
var CHAR_UNDERSCORE = x_ord("_"); // Underscore.
var CHAR_LOWER_A = x_ord("a"); // Lowercase letter A.
var CHAR_LOWER_N = x_ord("n"); // Lowercase letter N.
var CHAR_LOWER_R = x_ord("r"); // Lowercase letter R.
var CHAR_LOWER_T = x_ord("t"); // Lowercase letter T.
var CHAR_LOWER_Z = x_ord("z"); // Lowercase letter Z.
var CHAR_DELETE = 127; // Delete.
var CHAR_CONTINUE_1 = 128 + 64; // UTF-8, 1 continuation byte.
var CHAR_CONTINUE_2 = 128 + 64 + 32; // UTF-8, 2 continuation bytes.
var CHAR_CONTINUE_3 = 128 + 64 + 32 + 16; // UTF-8, 3 continuation bytes.

// MODULE // `string/string.lox` // ========================================= //

// A boxed string that can be manipulated.
class String {
	// Initialize the boxed string's string.
	init(){
		// The boxed string's string.
		this.string = "";
	}
	
	// Wrap the boxed string in quotes and return the boxed string.
	quote(){
		var quote_string = x_chr(CHAR_QUOTE);
		var length = x_length(this.string);
		var escaped = "";
		
		for(var i = 0; i < length; i = i + 1){
			var char_string = x_substring(this.string, i, 1);
			var char = x_ord(char_string);
			
			if(char == CHAR_TAB){
				escaped = escaped + "\t";
			} else if(char == CHAR_LINE){
				escaped = escaped + "\n";
			} else if(char == CHAR_CR){
				escaped = escaped + "\r";
			} else if(char == CHAR_QUOTE){
				escaped = escaped + "\" + quote_string;
			} else if(char == CHAR_APOSTROPHE){
				escaped = escaped + "\'";
			} else if(char == CHAR_BACKSLASH){
				escaped = escaped + "\\";
			} else {
				escaped = escaped + char_string;
			}
		}
		
		this.string = quote_string + escaped + quote_string;
		return this;
	}
	
	// Append a string to the boxed string and return the boxed string.
	append(value){
		this.string = this.string + value;
		return this;
	}
	
	// Append an integer to the boxed string and return the boxed string.
	append_int(value){
		var formatted = "";
		
		if(value < 0){
			value = -value;
			formatted = "-";
		}
		
		var place = 10;
		
		while(place <= value){
			place = place * 10;
		}
		
		while(place >= 10){
			place = place / 10;
			var digit = x_trunc(value / place);
			value = value - digit * place;
			formatted = formatted + x_chr(CHAR_0 + digit);
		}
		
		this.string = this.string + formatted;
		return this;
	}
	
	// Put the boxed string to an output stream with a trailing line feed.
	put_line(stream){
		var length = x_length(this.string);
		
		for(var i = 0; i < length; i = i + 1){
			x_put(x_ord(x_substring(this.string, i, 1)), stream);
		}
		
		x_put(CHAR_LINE, stream);
	}
	
	// Return the boxed string represented as a string.
	to_string(){
		return this.string;
	}
}

// MODULE // `collections/list_node.lox` // ================================= //

// A node of a list.
class ListNode {
	// Initialize the list node's element and list nodes.
	init(element, previous){
		// The list node's element.
		this.element = element;
		
		// The list node's previous list node.
		this.previous = previous;
		
		// The list node's next list node.
		this.next = nil;
	}
}

// MODULE // `collections/list_iterator.lox` // ============================= //

// An iterator for a list.
class ListIterator {
	// Initialize the list iterator's next list node.
	init(next_node){
		// The list iterator's next list node.
		this.next_node = next_node;
	}
	
	// Return whether the list iterator has a next element.
	has_next(){
		return this.next_node != nil;
	}
	
	// Return the list iterator's next element.
	get_next(){
		var node = this.next_node;
		
		if(!node){
			return nil;
		}
		
		this.next_node = node.next;
		return node.element;
	}
}

// MODULE // `collections/list.lox` // ====================================== //

// A list of elements.
class List {
	// Initialize the list's list nodes.
	init(){
		// The list's front node.
		this.head = nil;
		
		// The list's back node.
		this.tail = nil;
	}
	
	// Clear the list.
	clear(){
		this.head = nil;
		this.tail = nil;
	}
	
	// Return whether the list has no elements.
	is_empty(){
		return this.head == nil;
	}
	
	// Append an element to the back of the list.
	push_back(element){
		var node = ListNode(element, this.tail);
		
		if(node.previous){
			node.previous.next = node;
		} else {
			this.head = node;
		}
		
		this.tail = node;
	}
	
	// Remove and return an element from the back of the list.
	pop_back(){
		var node = this.tail;
		
		if(!node){
			return nil;
		}
		
		if(node.previous){
			node.previous.next = nil;
			this.tail = node.previous;
		} else {
			this.clear();
		}
		
		return node.element;
	}
	
	// Return the list joined as a string with a separator.
	join(separator){
		var node = this.head;
		var string = "";
		
		while(node){
			string = string + node.element;
			node = node.next;
			
			if(node){
				string = string + separator;
			}
		}
		
		return string;
	}
	
	// Return a new list iterator for the list.
	iter(){
		return ListIterator(this.head);
	}
}

// MODULE // `collections/map_node.lox` // ================================== //

// A node of a map.
class MapNode {
	// Initialize the map node's key, value, and next map node.
	init(key, value, next){
		// The map node's key.
		this.key = key;
		
		// The map node's value.
		this.value = value;
		
		// The map node's next map node.
		this.next = next;
	}
}

// MODULE // `collections/map.lox` // ======================================= //

// A map of keys to values.
class Map {
	// Initialize the map's map nodes.
	init(){
		// The map's most recently created map node.
		this.head = nil;
	}
	
	// Insert a key-value pair into the map.
	insert(key, value){
		var node = this.find_node(key);
		
		if(node){
			node.value = value;
		} else {
			this.head = MapNode(key, value, this.head);
		}
	}
	
	// Return a value from the map from its key.
	get(key){
		var node = this.find_node(key);
		
		if(node){
			return node.value;
		} else {
			return nil;
		}
	}
	
	// Return a map node from its key if it exists.
	find_node(key){
		var node = this.head;
		
		while(node){
			if(node.key == key){
				return node;
			}
			
			node = node.next;
		}
		
		return nil;
	}
}

// MODULE // `logger/span.lox` // =========================================== //

// A span between two positions in a module or the lack of a span.
class Span {
	// Initialize the span's module name and positions.
	init(){
		// The span's module name.
		this.module = "";
		
		// The line number of the span's start position.
		this.start_line = 0;
		
		// The column number of the span's start position.
		this.start_column = 0;
		
		// The line number of the span's end position.
		this.end_line = 0;
		
		// The column number of the span's end position.
		this.end_column = 0;
	}
	
	// Reset the span to the start of a module from its module name.
	reset(module){
		this.module = module;
		this.start_line = 1;
		this.start_column = 1;
		this.end_line = 1;
		this.end_column = 1;
	}
	
	// Extend the span's end position from a character.
	extend_from_char(char){
		if(char == CHAR_TAB){
			this.end_column = this.end_column + 4;
		} else if(char == CHAR_LINE){
			this.end_line = this.end_line + 1;
			this.end_column = 1;
		} else if(char != CHAR_EOF and char != CHAR_CR){
			this.end_column = this.end_column + 1;
		}
	}
	
	// Extend the span's end position from a span.
	extend_from_span(span){
		this.end_line = span.end_line;
		this.end_column = span.end_column;
	}
	
	// Shrink the span to its end position.
	shrink_to_end(){
		this.start_line = this.end_line;
		this.start_column = this.end_column;
	}
	
	// Return a new copy of the span.
	clone(){
		var target = Span();
		target.clone_from(this);
		return target;
	}
	
	// Copy the span's value from a source span.
	clone_from(source){
		this.module = source.module;
		this.start_line = source.start_line;
		this.start_column = source.start_column;
		this.end_line = source.end_line;
		this.end_column = source.end_column;
	}
	
	// Return the span represented as a string.
	to_string(){
		if(this.start_line < 1){
			return "[Global]";
		}
		
		var string = String().append_int(this.start_line).append(":").append_int(this.start_column);
		
		if(this.end_line > this.start_line){
			string.append(" > ").append_int(this.end_line).append(":").append_int(this.end_column);
		} else if(this.end_column > this.start_column){
			string.append("-").append_int(this.end_column);
		}
		
		return "[" + this.module + ":" + string.to_string() + "]";
	}
}

// MODULE // `logger/log_record.lox` // ===================================== //

// A log record containing a message and a span.
class LogRecord {
	// Initialize the log record's message and span.
	init(message, span){
		// The log record's message.
		this.message = message;
		
		// The log record's span.
		this.span = span;
	}
	
	// Return the log record represented as a string.
	to_string(){
		return this.span.to_string() + " " + this.message;
	}
}

// MODULE // `logger/logger.lox` // ========================================= //

// Logs messages at spans.
class Logger {
	// Initialize the logger's log record list.
	init(){
		// The logger's log record list.
		this.records = List();
	}
	
	// Output and clear the logger's messages.
	flush(){
		var iter = this.records.iter();
		var stream = x_stderr();
		
		while(iter.has_next()){
			String().append(iter.get_next().to_string()).put_line(stream);
		}
		
		this.records.clear();
	}
	
	// Log a message.
	log(message){
		this.log_at(message, Span());
	}
	
	// Log a message at a span.
	log_at(message, span){
		this.records.push_back(LogRecord(message, span.clone()));
	}
}

// MODULE // `lexer/token_type.lox` // ====================================== //

// Contains data about token types.
class TokenType {
	// Initialize the token type data.
	init(){
		// A map of token types to token type names.
		this.type_names = Map();
		
		// A map of lexemes to token types.
		this.lexeme_types = Map();
		
		var type_count = 0;
		
		// Define and return a new token type from its name or lexeme.
		fun create_type(name){
			var type = type_count;
			
			if(x_substring(name, 0, 1) == "'"){
				this.type_names.insert(type, x_substring(name, 1, x_length(name) - 2));
			} else {
				this.type_names.insert(type, "`" + name + "`");
				this.lexeme_types.insert(name, type);
			}
			
			type_count = type_count + 1;
			return type;
		}
		
		// A token type representing a syntax error, whitespace, or a comment.
		this.NONE = create_type("'non-token'");
		
		// A token type representing the end of a module.
		this.EOF = create_type("'end of file'");
		
		// A token type representing a string literal.
		this.STRING = create_type("'string'");
		
		// A token type representing an identifier.
		this.IDENTIFIER = create_type("'identifier'");
		
		// A token type representing the `as` keyword.
		this.AS = create_type("as");
		
		// A token type representing the `export` keyword.
		this.EXPORT = create_type("export");
		
		// A token type representing the `fn` keyword.
		this.FN = create_type("fn");
		
		// A token type representing the `import` keyword.
		this.IMPORT = create_type("import");
		
		// A token type representing the `print` keyword.
		this.PRINT = create_type("print");
		
		// A token type representing the `(` lexeme.
		this.OPEN_PAREN = create_type("(");
		
		// A token type representing the `)` lexeme.
		this.CLOSE_PAREN = create_type(")");
		
		// A token type representing the `,` lexeme.
		this.COMMA = create_type(",");
		
		// A token type representing the `;` lexeme.
		this.SEMICOLON = create_type(";");
		
		// A token type representing the `{` lexeme.
		this.OPEN_BRACE = create_type("{");
		
		// A token type representing the `}` lexeme.
		this.CLOSE_BRACE = create_type("}");
	}
	
	// Return a token type's name.
	get_name(type){
		return this.type_names.get(type);
	}
	
	// Return a token type from a lexeme.
	from_lexeme(lexeme){
		return this.lexeme_types.get(lexeme);
	}
}

// The token type data singleton.
var TokenType = TokenType();

// MODULE // `lexer/token.lox` // =========================================== //

// Contains a lexeme's data.
class Token {
	// Initialize the token's type, value, and span.
	init(type, value, span){
		// The token's type.
		this.type = type;
		
		// The token's value.
		this.value = value;
		
		// The token's span.
		this.span = span;
	}
	
	// Return the token represented as a string.
	to_string(){
		var literal = nil;
		
		if(this.type == TokenType.STRING){
			literal = String().append(this.value).quote().to_string();
		} else if(this.type == TokenType.IDENTIFIER){
			literal = this.value;
		}
		
		var name = TokenType.get_name(this.type);
		
		if(literal){
			return name + " `" + literal + "`";
		} else {
			return name;
		}
	}
}

// MODULE // `lexer/lexer.lox` // =========================================== //

// Scans a stream of tokens from an input stream.
class Lexer {
	// Initialize the lexer's logger, span, input stream, and next character.
	init(logger){
		// The lexer's logger.
		this.logger = logger;
		
		// Whether the lexer has encountered any syntax errors.
		this.has_errors = false;
		
		// The lexer's span.
		this.span = Span();
		
		// The lexer's input stream.
		this.stream = -1;
		
		// The lexer's next character.
		this.next = CHAR_EOF;
	}
	
	// Reset the lexer from a module name and an input stream.
	reset(module, stream){
		this.span.reset(module);
		this.stream = stream;
		this.has_errors = false;
		this.next = CHAR_EOF;
		this.advance();
	}
	
	// Return the next token from the lexer.
	scan_token(){
		var token = this.scan_raw_token();
		
		while(token.type == TokenType.NONE){
			token = this.scan_raw_token();
		}
		
		return token;
	}
	
	// Return the next token or none token from the lexer.
	scan_raw_token(){
		// Return whether a character is an alphabetical character.
		fun is_alpha(char){
			return (
				char >= CHAR_LOWER_A and char <= CHAR_LOWER_Z
				or char == CHAR_UNDERSCORE
				or char >= CHAR_UPPER_A and char <= CHAR_UPPER_Z
			);
		}
		
		// Return whether the next character matches a predicate.
		fun match(predicate){
			return predicate(this.next);
		}
		
		// Advance if the next character matches a character.
		fun accept(char){
			if(this.next == char){
				this.advance();
				return true;
			} else {
				return false;
			}
		}
		
		// Return a new token at the current span from its type and value.
		fun make_literal_token(type, value){
			return Token(type, value, this.span.clone());
		}
		
		// Return a new token at the current span from its type.
		fun make_token(type){
			return make_literal_token(type, nil);
		}
		
		this.span.shrink_to_end();
		
		if(this.next == CHAR_EOF){
			return make_token(TokenType.EOF);
		} else if(accept(CHAR_ILLEGAL)){
			return make_token(TokenType.NONE);
		} else if(match(this.is_whitespace)){
			this.advance();
			
			while(match(this.is_whitespace)){
				this.advance();
			}
			
			return make_token(TokenType.NONE);
		} else if(accept(CHAR_SLASH)){
			if(accept(CHAR_ASTERISK)){
				var depth = 1;
				
				while(depth > 0 and this.next != CHAR_EOF){
					if(accept(CHAR_ASTERISK)){
						if(accept(CHAR_SLASH)){
							depth = depth - 1;
						}
					} else if(accept(CHAR_SLASH)){
						if(accept(CHAR_ASTERISK)){
							depth = depth + 1;
						}
					} else {
						this.advance();
					}
				}
				
				if(depth > 0){
					this.log_error("Unterminated block comment.");
				}
				
				return make_token(TokenType.NONE);
			} else if(accept(CHAR_SLASH)){
				// Return whether a character is a line comment terminator.
				fun is_line_comment_terminator(char){
					return char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR;
				}
				
				while(!match(is_line_comment_terminator)){
					this.advance();
				}
				
				return make_token(TokenType.NONE);
			} else {
				this.log_error("Illegal character `/`.");
				return make_token(TokenType.NONE);
			}
		} else if(accept(CHAR_QUOTE)){
			// Return whether a character is a string terminator.
			fun is_string_terminator(char){
				return (
					char == CHAR_QUOTE or char == CHAR_LINE or char == CHAR_EOF or char == CHAR_CR
				);
			}
			
			var value = "";
			
			while(!match(is_string_terminator)){
				if(accept(CHAR_BACKSLASH)){
					if(accept(CHAR_QUOTE)){
						value = value + x_chr(CHAR_QUOTE);
					} else if(accept(CHAR_APOSTROPHE)){
						value = value + "'";
					} else if(accept(CHAR_BACKSLASH)){
						value = value + "\";
					} else if(accept(CHAR_LOWER_N)){
						value = value + x_chr(CHAR_LINE);
					} else if(accept(CHAR_LOWER_R)){
						value = value + x_chr(CHAR_CR);
					} else if(accept(CHAR_LOWER_T)){
						value = value + x_chr(CHAR_TAB);
					} else {
						var error_span = this.span.clone();
						error_span.shrink_to_end();
						
						if(this.next == CHAR_EOF){
							this.log_error_at("Expected escape character after `\`.", error_span);
						} else {
							error_span.extend_from_char(this.advance());
							this.log_error_at("Illegal escape character.", error_span);
						}
					}
				} else {
					value = value + x_chr(this.advance());
				}
			}
			
			if(!accept(CHAR_QUOTE)){
				this.log_error("Unterminated string.");
			}
			
			return make_literal_token(TokenType.STRING, value);
		} else if(match(is_alpha)){
			// Return whether a character is an alphanumeric character.
			fun is_alphanumeric(char){
				return is_alpha(char) or char >= CHAR_0 and char <= CHAR_9;
			}
			
			var value = x_chr(this.advance());
			
			while(match(is_alphanumeric)){
				value = value + x_chr(this.advance());
			}
			
			var type = TokenType.from_lexeme(value);
			
			if(type){
				return make_token(type);
			} else {
				return make_literal_token(TokenType.IDENTIFIER, value);
			}
		} else {
			var lexeme = x_chr(this.advance());
			var type = TokenType.from_lexeme(lexeme);
			
			if(type){
				return make_token(type);
			}
			
			this.log_error("Illegal character `" + lexeme + "`.");
			return make_token(TokenType.NONE);
		}
	}
	
	// Log an error message at the current span.
	log_error(message){
		this.log_error_at(message, this.span);
	}
	
	// Log an error message at a span.
	log_error_at(message, span){
		this.logger.log_at(message, span);
		this.has_errors = true;
	}
	
	// Return whether a character is a whitespace character.
	is_whitespace(char){
		return char == CHAR_SPACE or char == CHAR_TAB or char == CHAR_LINE or char == CHAR_CR;
	}
	
	// Advance to the next character and return the new current character.
	advance(){
		// Log an error message and return an illegal character.
		fun illegal(message){
			var error_span = this.span.clone();
			error_span.shrink_to_end();
			error_span.extend_from_char(CHAR_ILLEGAL);
			this.log_error_at(message, error_span);
			return CHAR_ILLEGAL;
		}
		
		var current = this.next;
		this.span.extend_from_char(current);
		var next = x_get(this.stream);
		
		if(!next){
			x_close(this.stream);
			next = CHAR_EOF;
		} else if(next == CHAR_DELETE or next < CHAR_SPACE and !this.is_whitespace(next)){
			next = illegal("Krox source cannot contain control characters.");
		} else if(next > CHAR_DELETE){
			var skip_count = 0;
			
			if(next >= CHAR_CONTINUE_3){
				skip_count = 3;
			} else if(next >= CHAR_CONTINUE_2){
				skip_count = 2;
			} else if(next >= CHAR_CONTINUE_1){
				skip_count = 1;
			}
			
			// Assume UTF-8, skip continuation bytes.
			while(skip_count > 0){
				next = x_get(this.stream);
				skip_count = skip_count - 1;
				
				if(!next){
					x_close(this.stream);
					skip_count = 0;
				}
			}
			
			next = illegal("Krox source cannot contain non-ASCII characters.");
		}
		
		this.next = next;
		return current;
	}
}

// MODULE // `ast/ast_node.lox` // ========================================== //

// A node of an abstract syntax tree.
class ASTNode {
	// Initialize the AST node's span.
	init(){
		// The AST node's span.
		this.span = Span();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return nil;
	}
}

// MODULE // `ast/nodes/block_stmt_ast_node.lox` // ========================= //

// A block statement node of an abstract syntax tree.
class BlockStmtASTNode < ASTNode {
	// Initialize the block statement AST node's statement list.
	init(){
		super.init();
		
		// The block statement AST node's statement list.
		this.statements = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_block_stmt(this);
	}
}

// MODULE // `ast/nodes/export_ast_node.lox` // ============================= //

// An export node of an abstract syntax tree.
class ExportASTNode < ASTNode {
	// Initialize the export AST node's export item list.
	init(){
		super.init();
		
		// The export AST node's export item list.
		this.items = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_export(this);
	}
}

// MODULE // `ast/nodes/export_item_ast_node.lox` // ======================== //

// An export item node of an abstract syntax tree.
class ExportItemASTNode < ASTNode {
	// Initialize the export item AST node's identifier tokens.
	init(internal, external){
		super.init();
		
		// The export item AST node's internal identifier token.
		this.internal = internal;
		
		// The export item AST node's optional external identifier token.
		this.external = external;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_export_item(this);
	}
}

// MODULE // `ast/nodes/expr_stmt_ast_node.lox` // ========================== //

// An expression statement node of an abstract syntax tree.
class ExprStmtASTNode < ASTNode {
	// Initialize the expression statement AST node's expression.
	init(expression){
		super.init();
		
		// The expression statement AST node's expression.
		this.expression = expression;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_expr_stmt(this);
	}
}

// MODULE // `ast/nodes/fn_stmt_ast_node.lox` // ============================ //

// A function statement node of an abstract syntax tree.
class FnStmtASTNode < ASTNode {
	// Initialize the function statement AST node's identifier token and body.
	init(identifier, body){
		super.init();
		
		// The function statement AST node's identifier token.
		this.identifier = identifier;
		
		// The function statement AST node's body.
		this.body = body;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_fn_stmt(this);
	}
}

// MODULE // `ast/nodes/import_ast_node.lox` // ============================= //

// An import node of an abstract syntax tree.
class ImportASTNode < ASTNode {
	// Initialize the import AST node's path token and import item list.
	init(path){
		super.init();
		
		// The import AST node's path token.
		this.path = path;
		
		// The optional name of the module imported by the import AST node.
		this.name = nil;
		
		// The import AST node's import item list.
		this.items = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_import(this);
	}
}

// MODULE // `ast/nodes/import_item_ast_node.lox` // ======================== //

// An import item node of an AST.
class ImportItemASTNode < ASTNode {
	// Initialize the import item AST node's identifier tokens.
	init(external, internal){
		super.init();
		
		// The import item AST node's external identifier token.
		this.external = external;
		
		// The import item AST node's optional internal identifier token.
		this.internal = internal;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_import_item(this);
	}
}

// MODULE // `ast/nodes/literal_expr_ast_node.lox` // ======================= //

// A literal expression node of an abstract syntax tree.
class LiteralExprASTNode < ASTNode {
	// Initialize the literal expression AST node's value.
	init(value){
		super.init();
		
		// The literal expression AST node's value.
		this.value = value;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_literal_expr(this);
	}
}

// MODULE // `ast/nodes/module_ast_node.lox` // ============================= //

// A module node of an abstract syntax tree.
class ModuleASTNode < ASTNode {
	// Initialize the module AST node's import and function lists.
	init(){
		super.init();
		
		// The module AST node's optional name.
		this.name = nil;
		
		// Whether the module AST node was parsed with no syntax errors.
		this.is_valid = true;
		
		// The module AST node's import list.
		this.imports = List();
		
		// The module AST node's export list.
		this.exports = List();
		
		// The module AST node's function list.
		this.functions = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_module(this);
	}
}

// MODULE // `ast/nodes/nop_stmt_ast_node.lox` // =========================== //

// A no operation statement node of an abstract syntax tree.
class NopStmtASTNode < ASTNode {
	// Initialize the no operation statement AST node.
	init(){
		super.init();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_nop_stmt(this);
	}
}

// MODULE // `ast/nodes/paren_expr_ast_node.lox` // ========================= //

// A parenthesized expression node of an abstract syntax tree.
class ParenExprASTNode < ASTNode {
	// Initialize the parenthesized expression AST node's expression.
	init(expression){
		super.init();
		
		// The parenthesized expression AST node's expression.
		this.expression = expression;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_paren_expr(this);
	}
}

// MODULE // `ast/nodes/print_stmt_ast_node.lox` // ========================= //

// A print statement node of an abstract syntax tree.
class PrintStmtASTNode < ASTNode {
	// Initialize the print statement AST node's expression.
	init(expression){
		super.init();
		
		// The print statement AST node's expression.
		this.expression = expression;
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_print_stmt(this);
	}
}

// MODULE // `ast/nodes/program_ast_node.lox` // ============================ //

// A program node of an abstract syntax tree.
class ProgramASTNode < ASTNode {
	// Initialize the program AST node's path and module list.
	init(path){
		super.init();
		
		// The program AST node's path.
		this.path = path;
		
		// The program AST node's module list.
		this.modules = List();
	}
	
	// Accept an AST visitor and return a value.
	accept_visitor(visitor){
		return visitor.visit_program(this);
	}
}

// MODULE // `ast/ast_visitor.lox` // ======================================= //

// Visits AST nodes and returns values for each type of AST node.
class ASTVisitor {
	// Initialize the AST visitor.
	init(){}
	
	// Visit an AST node and return a value.
	visit(node){
		return node.accept_visitor(this);
	}
	
	// Visit a block statement AST node and return a value.
	visit_block_stmt(node){
		return nil;
	}
	
	// Visit an export AST node and return a value.
	visit_export(node){
		return nil;
	}
	
	// Visit an export item AST node and return a value.
	visit_export_item(node){
		return nil;
	}
	
	// Visit an expression statement AST node and return a value.
	visit_expr_stmt(node){
		return nil;
	}
	
	// Visit a function statement AST node and return a value.
	visit_fn_stmt(node){
		return nil;
	}
	
	// Visit an import AST node and return a value.
	visit_import(node){
		return nil;
	}
	
	// Visit an import item AST node and return a value.
	visit_import_item(node){
		return nil;
	}
	
	// Visit a literal expression AST node and return a value.
	visit_literal_expr(node){
		return nil;
	}
	
	// Visit a module AST node and return a value.
	visit_module(node){
		return nil;
	}
	
	// Visit a no operation statement AST node and return a value.
	visit_nop_stmt(node){
		return nil;
	}
	
	// Visit a parenthesized expression AST node and return a value.
	visit_paren_expr(node){
		return nil;
	}
	
	// Visit a print statement AST node and return a value.
	visit_print_stmt(node){
		return nil;
	}
	
	// Visit a program AST node and return a value.
	visit_program(node){
		return nil;
	}
}

// MODULE // `ast/printer/ast_printer_node.lox` // ========================== //

// A generic tree node for printing an AST.
class ASTPrinterNode {
	// Initialize the AST printer node's message and child list.
	init(message){
		// The AST printer node's message.
		this.message = message;
		
		// The AST printer node's child list.
		this.children = List();
	}
	
	// Append an AST printer node to the AST printer node's children.
	append(node){
		this.children.push_back(node);
	}
	
	// Recursively print the AST printer node and its children.
	print_node(flags){
		var iter = flags.iter();
		var prefix = "";
		
		while(iter.has_next()){
			var flag = iter.get_next();
			
			if(iter.has_next()){
				if(flag){
					prefix = prefix + "|  ";
				} else {
					prefix = prefix + "   ";
				}
			} else {
				if(flag){
					prefix = prefix + "|--";
				} else {
					prefix = prefix + "|__";
				}
			}
		}
		
		print prefix + this.message;
		iter = this.children.iter();
		
		while(iter.has_next()){
			var child = iter.get_next();
			flags.push_back(iter.has_next());
			child.print_node(flags);
			flags.pop_back();
		}
	}
}

// MODULE // `ast/printer/ast_printer.lox` // =============================== //

// An AST visitor that prints an AST.
class ASTPrinter < ASTVisitor {
	// Initialize the AST printer's current AST printer node.
	init(){
		super.init();
		
		// The AST printer's current AST printer node.
		this.current = nil;
	}
	
	// Print an AST from its root node.
	print_ast(node){
		this.visit(node).print_node(List());
	}
	
	// Visit a block statement AST node and return an AST printer node.
	visit_block_stmt(node){
		this.begin("BlockStmt", node);
		this.append_node_list("statements", node.statements);
		return this.end();
	}
	
	// Visit an export AST node and return an AST printer node.
	visit_export(node){
		this.begin("Export", node);
		this.append_node_list("items", node.items);
		return this.end();
	}
	
	// Visit an export item AST node and return an AST printer node.
	visit_export_item(node){
		this.begin("ExportItem", node);
		this.append_token("internal", node.internal);
		
		if(node.external){
			this.append_token("external", node.external);
		}
		
		return this.end();
	}
	
	// Visit an expression statement AST node and return an AST printer node.
	visit_expr_stmt(node){
		this.begin("ExprStmt", node);
		this.append_node("expression", node.expression);
		return this.end();
	}
	
	// Visit a function statement AST node and return an AST printer node.
	visit_fn_stmt(node){
		this.begin("FnStmt", node);
		this.append_token("identifier", node.identifier);
		this.append_node("body", node.body);
		return this.end();
	}
	
	// Visit an import AST node and return an AST printer node.
	visit_import(node){
		this.begin("Import", node);
		this.append_token("path", node.path);
		
		if(node.name){
			this.append_string("name", node.name);
		}
		
		this.append_node_list("items", node.items);
		return this.end();
	}
	
	// Visit an import item AST node and return an AST printer node.
	visit_import_item(node){
		this.begin("ImportItem", node);
		this.append_token("external", node.external);
		
		if(node.internal){
			this.append_token("internal", node.internal);
		}
		
		return this.end();
	}
	
	// Visit a literal expression AST node and return an AST printer node.
	visit_literal_expr(node){
		this.begin("LiteralExpr", node);
		this.append_string("value", node.value);
		return this.end();
	}
	
	// Visit a module AST node and return an AST printer node.
	visit_module(node){
		this.begin("Module", node);
		
		if(node.name){
			this.append_string("name", node.name);
		}
		
		this.append_bool("is_valid", node.is_valid);
		this.append_node_list("imports", node.imports);
		this.append_node_list("exports", node.exports);
		this.append_node_list("functions", node.functions);
		return this.end();
	}
	
	// Visit a no operation statement AST node and return an AST printer node.
	visit_nop_stmt(node){
		this.begin("NopStmt", node);
		return this.end();
	}
	
	// Visit a parenthesized expression AST node and return an AST printer node.
	visit_paren_expr(node){
		this.begin("ParenExpr", node);
		this.append_node("expression", node.expression);
		return this.end();
	}
	
	// Visit a print statement AST node and return an AST printer node.
	visit_print_stmt(node){
		this.begin("PrintStmt", node);
		this.append_node("expression", node.expression);
		return this.end();
	}
	
	// Visit a program AST node and return an AST printer node.
	visit_program(node){
		this.begin("Program", node);
		this.append_string("path", node.path);
		this.append_node_list("modules", node.modules);
		return this.end();
	}
	
	// Begin a new current AST printer node from a name and an AST node.
	begin(name, node){
		this.current = ASTPrinterNode("(" + name + " " + node.span.to_string() + ")");
	}
	
	// Append a list of AST nodes to the current AST printer node from a name.
	append_node_list(name, list){
		var current = this.current;
		var list_node = ASTPrinterNode("[" + name + "]");
		var iter = list.iter();
		
		while(iter.has_next()){
			list_node.append(this.visit(iter.get_next()));
		}
		
		current.append(list_node);
		this.current = current;
	}
	
	// Append an AST node to the current AST printer node from a name.
	append_node(name, node){
		var current = this.current;
		var wrapper_node = ASTPrinterNode("{" + name + "}");
		wrapper_node.append(this.visit(node));
		current.append(wrapper_node);
		this.current = current;
	}
	
	// Append a token to the current AST printer node from a name.
	append_token(name, token){
		var wrapper_node = ASTPrinterNode("{" + name + "}");
		var message;
		
		if(token.type == TokenType.STRING){
			message = String().append(token.value).quote().to_string();
		} else if(token.type == TokenType.IDENTIFIER){
			message = token.value;
		} else {
			message = token.to_string();
		}
		
		wrapper_node.append(ASTPrinterNode("<" + message + " " + token.span.to_string() + ">"));
		this.current.append(wrapper_node);
	}
	
	// Append a boolean value to the current AST printer node from a name.
	append_bool(name, value){
		if(value){
			value = "true";
		} else {
			value = "false";
		}
		
		this.current.append(ASTPrinterNode("{" + name + ": " + value + "}"));
	}
	
	// Append a string to the current AST printer node from a name.
	append_string(name, value){
		this.current.append(
			ASTPrinterNode("{" + name + ": " + String().append(value).quote().to_string() + "}")
		);
	}
	
	// End and return the current AST printer node.
	end(){
		var current = this.current;
		this.current = nil;
		return current;
	}
}

// MODULE // `parser/parser.lox` // ========================================= //

// Parses an abstract syntax tree from a stream of tokens.
class Parser {
	// Initialize the parser's logger, lexer, and data.
	init(logger){
		// The parser's logger.
		this.logger = logger;
		
		// The parser's lexer.
		this.lexer = Lexer(logger);
		
		// Whether the parser has encountered any syntax errors.
		this.has_errors = false;
		
		// The parser's next token.
		this.next = Token(TokenType.EOF, nil, Span());
		
		// The parser's current span.
		this.current_span = Span();
		
		// The parser's span stack.
		this.span_stack = List();
	}
	
	// Reset the parser from a module name and an input stream.
	reset(module, stream){
		this.lexer.reset(module, stream);
		this.has_errors = false;
		this.advance();
	}
	
	// Parse and return a module AST node.
	parse_module(){
		this.begin();
		var module = ModuleASTNode();
		
		while(!this.match(TokenType.EOF)){
			var bump_token = this.next;
			
			if(this.match(TokenType.IMPORT)){
				this.try(this.parse_import, module.imports);
			} else if(this.match(TokenType.EXPORT)){
				this.try(this.parse_export, module.exports);
			} else if(this.match(TokenType.FN)){
				this.try(this.parse_fn_stmt, module.functions);
			} else {
				this.log_error("Expected `import`, `export`, or `fn`.");
			}
			
			if(this.next == bump_token){
				this.advance(); // Prevent infinite loop.
			}
		}
		
		if(this.has_errors or this.lexer.has_errors){
			module.is_valid = false;
		}
		
		return this.end(module);
	}
	
	// Parse and return an import AST node if possible.
	parse_import(){
		this.begin();
		this.expect(TokenType.IMPORT);
		var path = this.expect(TokenType.STRING);
		
		if(!path){
			return this.end(nil);
		}
		
		this.expect(TokenType.OPEN_BRACE);
		var accepts_item = true;
		var import = ImportASTNode(path);
		
		while(accepts_item and !this.match(TokenType.CLOSE_BRACE) and !this.match(TokenType.EOF)){
			this.try(this.parse_import_item, import.items);
			
			if(!this.accept(TokenType.COMMA)){
				accepts_item = false;
			}
		}
		
		this.expect(TokenType.CLOSE_BRACE);
		return this.end(import);
	}
	
	// Parse and return an import item AST node if possible.
	parse_import_item(){
		this.begin();
		var external = this.expect(TokenType.IDENTIFIER);
		
		if(!external){
			return this.end(nil);
		}
		
		var internal = nil;
		
		if(this.accept(TokenType.AS)){
			internal = this.expect(TokenType.IDENTIFIER);
		}
		
		return this.end(ImportItemASTNode(external, internal));
	}
	
	// Parse and return an export AST node.
	parse_export(){
		this.begin();
		this.expect(TokenType.EXPORT);
		this.expect(TokenType.OPEN_BRACE);
		var accepts_item = true;
		var export = ExportASTNode();
		
		while(accepts_item and !this.match(TokenType.CLOSE_BRACE) and !this.match(TokenType.EOF)){
			this.try(this.parse_export_item, export.items);
			
			if(!this.accept(TokenType.COMMA)){
				accepts_item = false;
			}
		}
		
		this.expect(TokenType.CLOSE_BRACE);
		return this.end(export);
	}
	
	// Parse and return an export item AST node if possible.
	parse_export_item(){
		this.begin();
		var internal = this.expect(TokenType.IDENTIFIER);
		
		if(!internal){
			return this.end(nil);
		}
		
		var external = nil;
		
		if(this.accept(TokenType.AS)){
			external = this.expect(TokenType.IDENTIFIER);
		}
		
		return this.end(ExportItemASTNode(internal, external));
	}
	
	// Parse and return a statement AST node if possible.
	parse_stmt(){
		this.begin();
		
		if(this.match(TokenType.FN)){
			return this.end(this.parse_fn_stmt());
		} else if(this.match(TokenType.OPEN_BRACE)){
			return this.end(this.parse_block_stmt());
		} else if(this.match(TokenType.PRINT)){
			return this.end(this.parse_print_stmt());
		} else if(this.match(TokenType.SEMICOLON)){
			return this.end(this.parse_nop_stmt());
		} else {
			return this.end(this.parse_expr_stmt());
		}
	}
	
	// Parse and return a function statement AST node if possible.
	parse_fn_stmt(){
		this.begin();
		this.expect(TokenType.FN);
		var identifier = this.expect(TokenType.IDENTIFIER);
		
		if(!identifier){
			return this.end(nil);
		}
		
		this.expect(TokenType.OPEN_PAREN);
		this.expect(TokenType.CLOSE_PAREN);
		return this.end(FnStmtASTNode(identifier, this.parse_block_stmt()));
	}
	
	// Parse and return a block statement AST node.
	parse_block_stmt(){
		this.begin();
		this.expect(TokenType.OPEN_BRACE);
		var block_stmt = BlockStmtASTNode();
		
		while(!this.match(TokenType.CLOSE_BRACE) and !this.match(TokenType.EOF)){
			var bump_token = this.next;
			this.try(this.parse_stmt, block_stmt.statements);
			
			if(this.next == bump_token){
				this.advance(); // Prevent infinite loop.
			}
		}
		
		this.expect(TokenType.CLOSE_BRACE);
		return this.end(block_stmt);
	}
	
	// Parse and return a print statement AST node.
	parse_print_stmt(){
		this.begin();
		this.expect(TokenType.PRINT);
		var expression = this.parse_paren_expr();
		
		if(!expression){
			return this.end(nil);
		}
		
		this.expect(TokenType.SEMICOLON);
		return this.end(PrintStmtASTNode(expression));
	}
	
	// Parse and return a no operation statement AST node.
	parse_nop_stmt(){
		this.begin();
		this.expect(TokenType.SEMICOLON);
		return this.end(NopStmtASTNode());
	}
	
	// Parse and return an expression statement AST node if possible.
	parse_expr_stmt(){
		this.begin();
		var expression = this.parse_expr();
		
		if(!expression){
			return this.end(nil);
		}
		
		this.expect(TokenType.SEMICOLON);
		return this.end(ExprStmtASTNode(expression));
	}
	
	// Parse and return an expression AST node if possible.
	parse_expr(){
		this.begin();
		return this.end(this.parse_primary_expr());
	}
	
	// Parse and return a primary expression AST node if possible.
	parse_primary_expr(){
		this.begin();
		
		if(this.match(TokenType.OPEN_PAREN)){
			return this.end(this.parse_paren_expr());
		} else if(this.match(TokenType.STRING)){
			return this.end(this.parse_literal_expr());
		} else {
			this.log_error("Expected a primary expression.");
			return this.end(nil);
		}
	}
	
	// Parse and return a parenthesized expression AST node if possible.
	parse_paren_expr(){
		this.begin();
		this.expect(TokenType.OPEN_PAREN);
		var expression = this.parse_expr();
		
		if(!expression){
			return this.end(nil);
		}
		
		this.expect(TokenType.CLOSE_PAREN);
		return this.end(ParenExprASTNode(expression));
	}
	
	// Parse and return a literal expression AST node if possible.
	parse_literal_expr(){
		this.begin();
		var value = this.expect(TokenType.STRING);
		
		if(!value){
			return this.end(nil);
		}
		
		return this.end(LiteralExprASTNode(value.value));
	}
	
	// Log an error message at the next token's span.
	log_error(message){
		this.log_error_at(message, this.next.span);
	}
	
	// Log an error message at a span.
	log_error_at(message, span){
		this.logger.log_at(message, span);
		this.has_errors = true;
	}
	
	// Begin an AST node.
	begin(){
		this.span_stack.push_back(this.next.span);
	}
	
	// End and return an AST node.
	end(node){
		if(node){
			node.span.clone_from(this.span_stack.pop_back());
			node.span.extend_from_span(this.current_span);
		}
		
		return node;
	}
	
	// Append the result of a parse rule to an AST node list if possible.
	try(rule, list){
		var node = rule();
		
		if(node){
			list.push_back(node);
		}
	}
	
	// Return whether the next token matches a token type.
	match(type){
		return this.next.type == type;
	}
	
	// Consume and return the next token if it matches a type.
	accept(type){
		if(this.match(type)){
			return this.advance();
		} else {
			return nil;
		}
	}
	
	// Consume and return the next token if it matches a type or log an error.
	expect(type){
		var consumed = this.accept(type);
		
		if(!consumed){
			this.log_error(
				"Expected " + TokenType.get_name(type) + ", got " + this.next.to_string() + "."
			);
		}
		
		return consumed;
	}
	
	// Advance to the next token and return the new current token.
	advance(){
		var current = this.next;
		this.current_span = current.span;
		this.next = this.lexer.scan_token();
		return current;
	}
}

// MODULE // `importer/importer.lox` // ===================================== //

// Imports a program from a collection of modules.
class Importer {
	// Initialize the importer's logger and parser.
	init(logger){
		// The importer's logger.
		this.logger = logger;
		
		// The importer's parser.
		this.parser = Parser(logger);
	}
	
	// Import and return a program from its main module's path.
	import_program(path){
		path = this.split_path(path);
		var name = path.pop_back();
		var program = ProgramASTNode(path.join("/"));
		
		if(!name){
			this.logger.log("Main module path cannot be empty.");
			return program;
		}
		
		if(!this.is_part_valid(name)){
			this.logger.log("Invalid main module path.");
			return program;
		}
		
		var queue = List();
		queue.push_back(name);
		
		while(!queue.is_empty()){
			this.import_queue(program, queue);
		}
		
		return program;
	}
	
	// Import a module to a program from a growable queue of module names.
	import_queue(program, queue){
		var name = queue.pop_back();
		
		if(!name or this.has_module(program, name)){
			return; // Empty queue or module already imported.
		}
		
		var stream = x_read(program.path + "/" + name);
		
		if(!stream){
			this.logger.log("Failed to open `" + name + "` for reading. File may not exist.");
			return;
		}
		
		this.parser.reset(name, stream);
		var module = this.parser.parse_module();
		
		if(x_close(stream)){
			this.logger.log("Parser failed to close `" + name + "` after reading.");
		}
		
		module.name = name;
		program.modules.push_back(module);
		var iter = module.imports.iter();
		
		while(iter.has_next()){
			this.resolve_import(name, iter.get_next(), queue);
		}
	}
	
	// Resolve a module's import and append the imported name to a queue.
	resolve_import(name, import, queue){
		var import_path = import.path.value;
		var import_span = import.path.span;
		
		if(import_path == ""){
			this.logger.log_at("Import paths cannot be empty.", import_span);
			return;
		}
		
		var import_path_leader = x_substring(import_path, 0, 1);
		var imported_name;
		
		if(import_path_leader == "/" or import_path_leader == "\"){
			import_path = x_substring(import_path, 1, x_length(import_path) - 1);
			imported_name = List(); // Absolute import path.
		} else {
			imported_name = this.split_path(name);
			imported_name.pop_back();
		}
		
		import_path = this.split_path(import_path);
		var iter = import_path.iter();
		
		while(iter.has_next()){
			var import_path_part = iter.get_next();
			
			if(import_path_part == "."){
				// Allow single dot to mean same directory.
			} else if(import_path_part == ".."){
				// Allow double dot to mean parent directory.
				if(imported_name.is_empty()){
					this.logger.log_at(
						"Import paths cannot ascend above the main directory.", import_span
					);
					return;
				}
				
				imported_name.pop_back();
			} else {
				if(!this.is_part_valid(import_path_part)){
					this.logger.log_at("Invalid import path.", import_span);
					return;
				}
				
				imported_name.push_back(import_path_part);
			}
		}
		
		imported_name = imported_name.join("/");
		
		if(imported_name == ""){
			this.logger.log_at("Import paths must contain a file name.", import_span);
			return;
		}
		
		if(imported_name == name){
			this.logger.log_at("Modules cannot import themselves.", import_span);
			return;
		}
		
		import.name = imported_name;
		queue.push_back(imported_name);
	}
	
	// Return whether a program has a module from its name.
	has_module(program, name){
		var iter = program.modules.iter();
		
		while(iter.has_next()){
			if(iter.get_next().name == name){
				return true;
			}
		}
		
		return false;
	}
	
	// Return whether a path part is valid.
	is_part_valid(part){
		var length = x_length(part);
		
		if(length < 1){
			return false; // Empty path parts are invalid.
		}
		
		if(x_substring(part, 0, 1) == " "){
			return false; // Leading spaces are invalid.
		}
		
		var trailer = x_substring(part, length - 1, 1);
		
		if(trailer == " " or trailer == "."){
			return false; // Trailing spaces or dots are invalid.
		}
		
		var previous = nil;
		
		for(var i = 0; i < length; i = i + 1){
			var current = x_substring(part, i, 1);
			
			if(current == previous and (current == " " or current == ".")){
				return false; // Adjacent spaces or dots are invalid.
			}
			
			if(
				current == "*"
				or current == "/"
				or current == ":"
				or current == "<"
				or current == ">"
				or current == "?"
				or current == "\"
				or current == "|"
			){
				return false; // Typical special characters are invalid.
			}
			
			var char = x_ord(current);
			
			if(char == CHAR_QUOTE or char < CHAR_SPACE or char >= CHAR_DELETE){
				return false; // Non printable characters are invalid.
			}
			
			previous = current;
		}
		
		return true;
	}
	
	// Split a path string to a list of path parts.
	split_path(path){
		var length = x_length(path);
		var part = "";
		var parts = List();
		
		for(var i = 0; i < length; i = i + 1){
			var char_string = x_substring(path, i, 1);
			
			if(char_string == "/" or char_string == "\"){
				parts.push_back(part);
				part = "";
			} else {
				part = part + char_string;
			}
		}
		
		if(part != ""){
			parts.push_back(part);
		}
		
		return parts;
	}
}

// MODULE // `tests/run_tests.lox` // ======================================= //

// Run tests from LoxKrox's path and a logger.
fun run_tests(path, logger){
	var importer = Importer(logger);
	var tests_path = importer.split_path(path);
	tests_path.pop_back();
	tests_path = tests_path.join("/") + "/tests/";
	
	// Run a test from a path.
	fun run_test(path){
		print "Testing `" + path + "`.";
		ASTPrinter().print_ast(importer.import_program(tests_path + path));
		logger.flush();
		print "";
	}
	
	run_test("test_imports/test_imports_main.krox");
	run_test("test_exports.krox");
	run_test("test_hello.krox");
	run_test("test_items.krox");
	
	print "End of tests.";
}

// MODULE // `core/main.lox` // ============================================= //

// Run LoxKrox from arguments.
fun main(){
	var logger = Logger();
	
	if(x_args() == 1){
		run_tests(x_arg(0), logger);
	} else {
		logger.log("Expected arguments `krox.lox`.");
	}
	
	logger.flush();
}

main();
